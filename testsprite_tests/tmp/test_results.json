[
  {
    "projectId": "438a93da-61b6-417f-96df-03acf219046d",
    "testId": "eea78ce5-e04b-4bf5-8a32-6a51568983fa",
    "userId": "3408e4a8-2001-7012-102b-59e7bbe0cb20",
    "title": "TC001-validate_hedge_start_accepts_account_a_alias",
    "description": "Test the /api/v1/hedge/start endpoint to ensure it accepts both 'account_a_name' and 'account_a' as valid fields for Account A without error, verifying backward compatibility with field aliasing.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000/api/v1/hedge/start\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_validate_hedge_start_accepts_account_a_alias():\n    # Common request payload template (except account_a_name/account_a)\n    common_payload = {\n        \"account_b_name\": \"AccountB_Test_01\",\n        \"instrument\": \"MNQ\",\n        \"direction\": \"long\",\n        \"entry_price\": 21000.0,\n        \"quantity\": 1,\n        \"tp_distance\": 10.0,\n        \"sl_distance\": 5.0,\n        \"hedge_distance\": 2.0\n    }\n\n    for alias_field in [\"account_a_name\", \"account_a\"]:\n        payload = common_payload.copy()\n        payload[alias_field] = \"AccountA_Test_01\"\n\n        try:\n            response = requests.post(\n                BASE_URL,\n                json=payload,\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n        except requests.RequestException as e:\n            assert False, f\"Request failed for {alias_field} alias: {e}\"\n\n        # Validate status code\n        assert response.status_code == 200, f\"Expected 200 OK for {alias_field} alias, got {response.status_code}\"\n\n        json_resp = response.json()\n        # Validate top-level status in response\n        assert \"status\" in json_resp, f\"'status' missing in response for {alias_field} alias\"\n        assert json_resp[\"status\"] in [\"success\", \"partial\", \"failed\"], f\"Unexpected status value for {alias_field} alias\"\n\n        # Validate both account results exist\n        assert \"account_a_result\" in json_resp, f\"'account_a_result' missing for {alias_field} alias\"\n        assert \"account_b_result\" in json_resp, f\"'account_b_result' missing for {alias_field} alias\"\n\n        # Account A result checks\n        a_result = json_resp[\"account_a_result\"]\n        assert a_result.get(\"account_name\") == payload[alias_field], f\"Account A name mismatch for {alias_field} alias\"\n        assert isinstance(a_result.get(\"status\"), str), f\"Account A status missing or invalid for {alias_field} alias\"\n        assert a_result.get(\"direction\") == payload[\"direction\"].lower(), f\"Account A direction mismatch for {alias_field} alias\"\n\n        # Account B result checks\n        b_result = json_resp[\"account_b_result\"]\n        assert b_result.get(\"account_name\") == payload[\"account_b_name\"], f\"Account B name mismatch for {alias_field} alias\"\n        expected_opposite_direction = \"short\" if payload[\"direction\"].lower() == \"long\" else \"long\"\n        assert b_result.get(\"direction\") == expected_opposite_direction, f\"Account B direction mismatch for {alias_field} alias\"\n\ntest_validate_hedge_start_accepts_account_a_alias()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 35, in test_validate_hedge_start_accepts_account_a_alias\nAssertionError: Expected 200 OK for account_a_name alias, got 503\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-25T21:03:23.670Z",
    "modified": "2025-10-25T21:04:01.006Z"
  },
  {
    "projectId": "438a93da-61b6-417f-96df-03acf219046d",
    "testId": "c71fa8fa-95de-468d-8479-6ff475a29a39",
    "userId": "3408e4a8-2001-7012-102b-59e7bbe0cb20",
    "title": "TC002-validate_hedge_start_input_validation",
    "description": "Test the /api/v1/hedge/start endpoint to verify input validation rejects negative quantities, zero or negative prices, invalid directions (only 'long' or 'short' allowed), and identical account names, ensuring robust request validation.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000/api/v1/hedge/start\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef validate_hedge_start_input_validation():\n    invalid_test_cases = [\n        # Negative quantity\n        {\n            \"account_a_name\": \"AccountA1\",\n            \"account_b_name\": \"AccountB1\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"long\",\n            \"entry_price\": 21000.25,\n            \"quantity\": -1,\n            \"tp_distance\": 5,\n            \"sl_distance\": 2,\n            \"hedge_distance\": 1,\n            \"expect_400\": True\n        },\n        # Zero quantity\n        {\n            \"account_a_name\": \"AccountA1\",\n            \"account_b_name\": \"AccountB2\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"long\",\n            \"entry_price\": 21000.25,\n            \"quantity\": 0,\n            \"tp_distance\": 5,\n            \"sl_distance\": 2,\n            \"hedge_distance\": 1,\n            \"expect_400\": True\n        },\n        # Zero entry price\n        {\n            \"account_a_name\": \"AccountA1\",\n            \"account_b_name\": \"AccountB3\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"long\",\n            \"entry_price\": 0,\n            \"quantity\": 1,\n            \"tp_distance\": 5,\n            \"sl_distance\": 2,\n            \"hedge_distance\": 1,\n            \"expect_400\": True\n        },\n        # Negative entry price\n        {\n            \"account_a_name\": \"AccountA1\",\n            \"account_b_name\": \"AccountB4\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"long\",\n            \"entry_price\": -100,\n            \"quantity\": 1,\n            \"tp_distance\": 5,\n            \"sl_distance\": 2,\n            \"hedge_distance\": 1,\n            \"expect_400\": True\n        },\n        # Zero tp_distance (allowed)\n        {\n            \"account_a_name\": \"AccountA1\",\n            \"account_b_name\": \"AccountB5\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"long\",\n            \"entry_price\": 21000.25,\n            \"quantity\": 1,\n            \"tp_distance\": 0,\n            \"sl_distance\": 2,\n            \"hedge_distance\": 1,\n            \"expect_400\": False\n        },\n        # Negative tp_distance (invalid)\n        {\n            \"account_a_name\": \"AccountA1\",\n            \"account_b_name\": \"AccountB6\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"long\",\n            \"entry_price\": 21000.25,\n            \"quantity\": 1,\n            \"tp_distance\": -1,\n            \"sl_distance\": 2,\n            \"hedge_distance\": 1,\n            \"expect_400\": True\n        },\n        # Negative sl_distance (invalid)\n        {\n            \"account_a_name\": \"AccountA1\",\n            \"account_b_name\": \"AccountB7\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"long\",\n            \"entry_price\": 21000.25,\n            \"quantity\": 1,\n            \"tp_distance\": 5,\n            \"sl_distance\": -2,\n            \"hedge_distance\": 1,\n            \"expect_400\": True\n        },\n        # Invalid direction (uppercase, valid directions are 'long' or 'short' only)\n        {\n            \"account_a_name\": \"AccountA1\",\n            \"account_b_name\": \"AccountB8\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"LONG\",\n            \"entry_price\": 21000.25,\n            \"quantity\": 1,\n            \"tp_distance\": 5,\n            \"sl_distance\": 2,\n            \"hedge_distance\": 1,\n            \"expect_400\": True\n        },\n        # Invalid direction (not long or short)\n        {\n            \"account_a_name\": \"AccountA1\",\n            \"account_b_name\": \"AccountB9\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"up\",\n            \"entry_price\": 21000.25,\n            \"quantity\": 1,\n            \"tp_distance\": 5,\n            \"sl_distance\": 2,\n            \"hedge_distance\": 1,\n            \"expect_400\": True\n        },\n        # Identical account names\n        {\n            \"account_a_name\": \"SameAccount\",\n            \"account_b_name\": \"SameAccount\",\n            \"instrument\": \"MNQ\",\n            \"direction\": \"long\",\n            \"entry_price\": 21000.25,\n            \"quantity\": 1,\n            \"tp_distance\": 5,\n            \"sl_distance\": 2,\n            \"hedge_distance\": 1,\n            \"expect_400\": True\n        },\n    ]\n\n    for i, test_case in enumerate(invalid_test_cases, start=1):\n        payload = {k: v for k, v in test_case.items() if k != \"expect_400\"}\n        expect_400 = test_case[\"expect_400\"]\n        try:\n            response = requests.post(BASE_URL, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        except requests.RequestException as e:\n            assert False, f\"Test case #{i} failed with request exception: {e}\"\n\n        if expect_400:\n            assert response.status_code == 400, f\"Test case #{i} expected 400 but got {response.status_code}. Payload: {payload}\"\n        else:\n            assert response.status_code == 200, f\"Test case #{i} expected 200 but got {response.status_code}. Payload: {payload}\"\n\nvalidate_hedge_start_input_validation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 154, in <module>\n  File \"<string>\", line 152, in validate_hedge_start_input_validation\nAssertionError: Test case #5 expected 200 but got 503. Payload: {'account_a_name': 'AccountA1', 'account_b_name': 'AccountB5', 'instrument': 'MNQ', 'direction': 'long', 'entry_price': 21000.25, 'quantity': 1, 'tp_distance': 0, 'sl_distance': 2, 'hedge_distance': 1}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-25T21:03:23.676Z",
    "modified": "2025-10-25T21:04:45.988Z"
  },
  {
    "projectId": "438a93da-61b6-417f-96df-03acf219046d",
    "testId": "e78d19aa-618d-4446-abc7-cabadf7068c8",
    "userId": "3408e4a8-2001-7012-102b-59e7bbe0cb20",
    "title": "TC003-validate_concurrent_order_placement_on_hedge_start",
    "description": "Test that the /api/v1/hedge/start endpoint places orders concurrently on both accounts using asyncio.gather(), ensuring reduced latency and slippage risk with correct token scopes for each account.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8000/api/v1/hedge/start\"\nTIMEOUT = 30  # seconds\n\ndef validate_concurrent_order_placement_on_hedge_start():\n    # Prepare hedge order request payload for concurrent order placement test\n    # Use two distinct accounts with assumed valid names and tokens in Redis\n    payload = {\n        \"account_a_name\": \"TEST_ACCOUNT_A_12345\",\n        \"account_b_name\": \"TEST_ACCOUNT_B_54321\",\n        \"instrument\": \"MNQ\",          # MNQ uses 0.25 tick size\n        \"direction\": \"long\",\n        \"entry_price\": 21000.13,       # Not rounded intentionally to verify backend rounding\n        \"quantity\": 1,\n        \"tp_distance\": 10,\n        \"sl_distance\": 5,\n        \"hedge_distance\": 2            # Price difference for account B entry\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    start_time = time.time()\n    try:\n        response = requests.post(BASE_URL, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    duration = time.time() - start_time\n\n    assert response.status_code == 200, f\"Expected status 200 OK but got {response.status_code}\"\n    data = response.json()\n\n    # Validate overall status\n    assert data.get(\"status\") in [\"success\", \"partial\"], \"Hedge order placement failed or returned unexpected status\"\n\n    # Validate account A result presence and correctness\n    account_a_result = data.get(\"account_a_result\")\n    assert account_a_result is not None, \"Missing account_a_result in response\"\n    assert account_a_result.get(\"account_name\") == payload[\"account_a_name\"], \"account_a_name mismatch\"\n    assert \"order_id\" in account_a_result and account_a_result[\"order_id\"], \"Missing order_id for account A\"\n    assert account_a_result.get(\"direction\") == payload[\"direction\"].lower(), \"Direction mismatch for account A\"\n    # entry_price should be rounded according to MNQ tick size (0.25). 21000.13 rounds to 21000.25\n    rounded_entry_a = round(payload[\"entry_price\"] / 0.25) * 0.25\n    assert abs(account_a_result.get(\"entry_price\", 0) - rounded_entry_a) < 1e-6, \"Entry price not correctly rounded for account A\"\n    # Validate stop_loss and take_profit presence and positive numbers\n    assert isinstance(account_a_result.get(\"stop_loss\"), (int, float)) and account_a_result[\"stop_loss\"] >= 0, \"Invalid stop_loss for account A\"\n    assert isinstance(account_a_result.get(\"take_profit\"), (int, float)) and account_a_result[\"take_profit\"] >= 0, \"Invalid take_profit for account A\"\n    # Status in account A result should be success or partial\n    assert account_a_result.get(\"status\") in [\"success\", \"partial\"], \"Order status for account A not success or partial\"\n    # error_message should be string or None/empty\n    assert \"error_message\" in account_a_result, \"Missing error_message field for account A\"\n\n    # Validate account B result presence and correctness\n    account_b_result = data.get(\"account_b_result\")\n    assert account_b_result is not None, \"Missing account_b_result in response\"\n    assert account_b_result.get(\"account_name\") == payload[\"account_b_name\"], \"account_b_name mismatch\"\n    assert \"order_id\" in account_b_result and account_b_result[\"order_id\"], \"Missing order_id for account B\"\n    # Account B direction is opposite of account A\n    expected_direction_b = \"short\" if payload[\"direction\"].lower() == \"long\" else \"long\"\n    assert account_b_result.get(\"direction\") == expected_direction_b, \"Direction mismatch for account B\"\n    # Account B entry price = entry_price \u00177 hedge_distance; account_a is long so account_b entry price = entry_price + hedge_distance\n    expected_entry_b = payload[\"entry_price\"] + payload[\"hedge_distance\"]\n    rounded_entry_b = round(expected_entry_b / 0.25) * 0.25\n    assert abs(account_b_result.get(\"entry_price\", 0) - rounded_entry_b) < 1e-6, \"Entry price not correctly rounded for account B\"\n    assert isinstance(account_b_result.get(\"stop_loss\"), (int, float)) and account_b_result[\"stop_loss\"] >= 0, \"Invalid stop_loss for account B\"\n    assert isinstance(account_b_result.get(\"take_profit\"), (int, float)) and account_b_result[\"take_profit\"] >= 0, \"Invalid take_profit for account B\"\n    assert account_b_result.get(\"status\") in [\"success\", \"partial\"], \"Order status for account B not success or partial\"\n    assert \"error_message\" in account_b_result, \"Missing error_message field for account B\"\n\n    # Validate timestamp presence and is a number\n    assert isinstance(data.get(\"timestamp\"), (int, float)), \"Missing or invalid timestamp\"\n\n    # Assert reasonable API response time indicating concurrency (e.g. must be less than 5 seconds, adjust if needed)\n    assert duration < 5, f\"API response took too long ({duration:.2f}s), concurrency may not be working properly\"\n\nvalidate_concurrent_order_placement_on_hedge_start()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 79, in <module>\n  File \"<string>\", line 33, in validate_concurrent_order_placement_on_hedge_start\nAssertionError: Expected status 200 OK but got 503\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-25T21:03:23.681Z",
    "modified": "2025-10-25T21:04:07.069Z"
  },
  {
    "projectId": "438a93da-61b6-417f-96df-03acf219046d",
    "testId": "1628dfc0-7855-4eee-89d2-a9befaa7f1ed",
    "userId": "3408e4a8-2001-7012-102b-59e7bbe0cb20",
    "title": "TC004-validate_price_rounding_to_instrument_tick_size",
    "description": "Test that all price inputs (entry price, take profit, stop loss) sent to the broker API from /api/v1/hedge/start are correctly rounded according to the instrument-specific tick sizes (e.g., 0.25 for ES/MES/NQ/MNQ, 1.0 for YM/MYM, 0.10 for RTY/M2K).",
    "code": "import requests\n\ndef test_validate_price_rounding_to_instrument_tick_size():\n    base_url = \"http://localhost:8000/api/v1/hedge/start\"\n    timeout = 30\n\n    # Instruments and their expected tick sizes\n    instruments_tick_sizes = {\n        \"ES\": 0.25,\n        \"MES\": 0.25,\n        \"NQ\": 0.25,\n        \"MNQ\": 0.25,\n        \"YM\": 1.0,\n        \"MYM\": 1.0,\n        \"RTY\": 0.10,\n        \"M2K\": 0.10,\n    }\n\n    # Sample accounts to test with (must be distinct)\n    account_a_name = \"TestAccountA\"\n    account_b_name = \"TestAccountB\"\n\n    # Helper function to round a price according to tick size\n    def round_price(price: float, tick_size: float) -> float:\n        return round(round(price / tick_size) * tick_size, 8)\n\n    # For testing, select representative test prices (choose odd decimals to check rounding)\n    test_entry_price = 21000.13\n    test_tp_distance = 5.37\n    test_sl_distance = 3.68\n    hedge_distance = 1.0\n\n    # Test each instrument\n    for instrument, tick_size in instruments_tick_sizes.items():\n        # Calculate expected rounded prices\n        entry_price_rounded = round_price(test_entry_price, tick_size)\n        tp_distance_rounded = round_price(test_tp_distance, tick_size)\n        sl_distance_rounded = round_price(test_sl_distance, tick_size)\n\n        payload = {\n            \"account_a_name\": account_a_name,\n            \"account_b_name\": account_b_name,\n            \"instrument\": instrument,\n            \"direction\": \"long\",\n            \"entry_price\": test_entry_price,\n            \"quantity\": 1,\n            \"tp_distance\": test_tp_distance,\n            \"sl_distance\": test_sl_distance,\n            \"hedge_distance\": hedge_distance,\n        }\n\n        try:\n            response = requests.post(base_url, json=payload, timeout=timeout)\n        except requests.RequestException as e:\n            assert False, f\"Request failed for instrument {instrument}: {e}\"\n\n        assert response.status_code == 200, f\"Expected 200 OK but got {response.status_code} for instrument {instrument}\"\n\n        data = response.json()\n        assert data.get(\"status\") in (\"success\", \"partial\", \"failed\"), f\"Unexpected status value for instrument {instrument}\"\n\n        acct_a = data.get(\"account_a_result\")\n        acct_b = data.get(\"account_b_result\")\n        assert acct_a is not None, f\"Missing account_a_result for instrument {instrument}\"\n        assert acct_b is not None, f\"Missing account_b_result for instrument {instrument}\"\n\n        # Validate account names match request\n        assert acct_a.get(\"account_name\") == account_a_name, f\"Account A name mismatch for {instrument}\"\n        assert acct_b.get(\"account_name\") == account_b_name, f\"Account B name mismatch for {instrument}\"\n\n        # Validate rounding for Account A prices (entry_price, take_profit, stop_loss)\n        # tp_distance and sl_distance are distances, but the response includes take_profit and stop_loss prices\n        entry_price_a = acct_a.get(\"entry_price\")\n        take_profit_a = acct_a.get(\"take_profit\")\n        stop_loss_a = acct_a.get(\"stop_loss\")\n\n        # Account A entered long at entry_price, take_profit = entry_price + tp_distance, stop_loss = entry_price - sl_distance\n        expected_tp_a = round_price(entry_price_rounded + tp_distance_rounded, tick_size)\n        expected_sl_a = round_price(entry_price_rounded - sl_distance_rounded, tick_size)\n\n        assert abs(entry_price_a - entry_price_rounded) < 1e-8, f\"Account A entry_price not rounded correctly for {instrument}\"\n        assert abs(take_profit_a - expected_tp_a) < 1e-8, f\"Account A take_profit not rounded correctly for {instrument}\"\n        assert abs(stop_loss_a - expected_sl_a) < 1e-8, f\"Account A stop_loss not rounded correctly for {instrument}\"\n\n        # Validate rounding for Account B prices\n        entry_price_b = acct_b.get(\"entry_price\")\n        take_profit_b = acct_b.get(\"take_profit\")\n        stop_loss_b = acct_b.get(\"stop_loss\")\n\n        # Account B direction is opposite (short), entry_price adjusted by hedge_distance:\n        if payload[\"direction\"].lower() == \"long\":\n            expected_entry_b = round_price(entry_price_rounded + hedge_distance, tick_size)\n            # For short: take_profit = entry_price - tp_distance, stop_loss = entry_price + sl_distance\n            expected_tp_b = round_price(expected_entry_b - tp_distance_rounded, tick_size)\n            expected_sl_b = round_price(expected_entry_b + sl_distance_rounded, tick_size)\n        else:\n            expected_entry_b = round_price(entry_price_rounded - hedge_distance, tick_size)\n            expected_tp_b = round_price(expected_entry_b + tp_distance_rounded, tick_size)\n            expected_sl_b = round_price(expected_entry_b - sl_distance_rounded, tick_size)\n\n        assert abs(entry_price_b - expected_entry_b) < 1e-8, f\"Account B entry_price not rounded correctly for {instrument}\"\n        assert abs(take_profit_b - expected_tp_b) < 1e-8, f\"Account B take_profit not rounded correctly for {instrument}\"\n        assert abs(stop_loss_b - expected_sl_b) < 1e-8, f\"Account B stop_loss not rounded correctly for {instrument}\"\n\ntest_validate_price_rounding_to_instrument_tick_size()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 105, in <module>\n  File \"<string>\", line 57, in test_validate_price_rounding_to_instrument_tick_size\nAssertionError: Expected 200 OK but got 400 for instrument ES\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-25T21:03:23.686Z",
    "modified": "2025-10-25T21:03:59.688Z"
  },
  {
    "projectId": "438a93da-61b6-417f-96df-03acf219046d",
    "testId": "ccc451cd-be90-430b-a0d2-0b8a9530026f",
    "userId": "3408e4a8-2001-7012-102b-59e7bbe0cb20",
    "title": "TC005-validate_trading_accounts_api_cache_support",
    "description": "Test the /api/v1/trading/accounts GET endpoint to verify it returns a list of trading accounts with correct caching behavior when the 'use_cache' query parameter is true or false.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000/api/v1/trading/accounts\"\nTIMEOUT = 30\n\ndef test_validate_trading_accounts_api_cache_support():\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n\n    # Test with use_cache=true\n    params_true = {\n        \"use_cache\": \"true\"\n    }\n    try:\n        response_true = requests.get(BASE_URL, headers=headers, params=params_true, timeout=TIMEOUT)\n        assert response_true.status_code == 200, f\"Expected 200, got {response_true.status_code}\"\n        data_true = response_true.json()\n\n        assert isinstance(data_true, dict), \"Response is not a JSON object\"\n        assert \"accounts\" in data_true, \"'accounts' key missing in response\"\n        assert isinstance(data_true[\"accounts\"], list), \"'accounts' is not a list\"\n        assert \"count\" in data_true and isinstance(data_true[\"count\"], int), \"'count' key missing or not int\"\n        assert \"cached\" in data_true and isinstance(data_true[\"cached\"], bool), \"'cached' key missing or not bool\"\n        assert data_true[\"cached\"] is True, \"Expected cached to be True when use_cache=true\"\n        assert \"timestamp\" in data_true and isinstance(data_true[\"timestamp\"], (int, float)), \"'timestamp' key missing or wrong type\"\n\n        for account in data_true[\"accounts\"]:\n            assert \"name\" in account and isinstance(account[\"name\"], str), \"Account missing 'name' or not string\"\n            assert \"id\" in account and isinstance(account[\"id\"], str), \"Account missing 'id' or not string\"\n            assert \"active\" in account and isinstance(account[\"active\"], bool), \"Account missing 'active' or not bool\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed with exception: {e}\"\n\n    # Test with use_cache=false\n    params_false = {\n        \"use_cache\": \"false\"\n    }\n    try:\n        response_false = requests.get(BASE_URL, headers=headers, params=params_false, timeout=TIMEOUT)\n        assert response_false.status_code == 200, f\"Expected 200, got {response_false.status_code}\"\n        data_false = response_false.json()\n\n        assert isinstance(data_false, dict), \"Response is not a JSON object\"\n        assert \"accounts\" in data_false, \"'accounts' key missing in response\"\n        assert isinstance(data_false[\"accounts\"], list), \"'accounts' is not a list\"\n        assert \"count\" in data_false and isinstance(data_false[\"count\"], int), \"'count' key missing or not int\"\n        assert \"cached\" in data_false and isinstance(data_false[\"cached\"], bool), \"'cached' key missing or not bool\"\n        assert data_false[\"cached\"] is False, \"Expected cached to be False when use_cache=false\"\n        assert \"timestamp\" in data_false and isinstance(data_false[\"timestamp\"], (int, float)), \"'timestamp' key missing or wrong type\"\n\n        for account in data_false[\"accounts\"]:\n            assert \"name\" in account and isinstance(account[\"name\"], str), \"Account missing 'name' or not string\"\n            assert \"id\" in account and isinstance(account[\"id\"], str), \"Account missing 'id' or not string\"\n            assert \"active\" in account and isinstance(account[\"active\"], bool), \"Account missing 'active' or not bool\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed with exception: {e}\"\n\ntest_validate_trading_accounts_api_cache_support()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-25T21:03:23.691Z",
    "modified": "2025-10-25T21:03:47.622Z"
  },
  {
    "projectId": "438a93da-61b6-417f-96df-03acf219046d",
    "testId": "62c3c539-6c6e-4a28-9703-fb4fda0205d9",
    "userId": "3408e4a8-2001-7012-102b-59e7bbe0cb20",
    "title": "TC006-validate_positions_api_minimal_latency_response",
    "description": "Test the /api/v1/trading/positions GET endpoint to ensure it returns active positions across accounts with minimal latency and supports filtering by comma-separated account IDs.",
    "code": "import requests\nfrom requests.exceptions import RequestException, Timeout\n\nBASE_URL = \"http://localhost:8000/api/v1/trading\"\nTIMEOUT = 30\n\ndef test_validate_positions_api_minimal_latency_response():\n    # Step 1: Get all trading accounts to obtain active account IDs\n    accounts_url = f\"{BASE_URL}/accounts\"\n    try:\n        accounts_resp = requests.get(accounts_url, params={\"use_cache\": True}, timeout=TIMEOUT)\n        accounts_resp.raise_for_status()\n    except (RequestException, Timeout) as e:\n        assert False, f\"Failed to get accounts: {e}\"\n\n    accounts_data = accounts_resp.json()\n    assert \"accounts\" in accounts_data, \"Response missing 'accounts' field\"\n    assert isinstance(accounts_data[\"accounts\"], list), \"'accounts' should be a list\"\n\n    # Filter active accounts and extract their IDs\n    active_account_ids = [acc[\"id\"] for acc in accounts_data[\"accounts\"] if acc.get(\"active\")]\n    assert len(active_account_ids) > 0, \"No active accounts found to test positions API\"\n\n    # Prepare comma-separated account_ids string\n    account_ids_param = \",\".join(active_account_ids[:5])  # limit to 5 accounts for test conciseness\n\n    # Step 2: Request positions for these account IDs\n    positions_url = f\"{BASE_URL}/positions\"\n    params = {\n        \"account_ids\": account_ids_param,\n        \"use_cache\": False  # per PRD default for minimal latency testing\n    }\n    try:\n        positions_resp = requests.get(positions_url, params=params, timeout=TIMEOUT)\n        positions_resp.raise_for_status()\n    except (RequestException, Timeout) as e:\n        assert False, f\"Failed to get positions: {e}\"\n\n    positions_data = positions_resp.json()\n    # Validate we received a list or dict (API doc states \"List of positions\" but schema isn't explicit)\n    assert positions_data is not None, \"Positions response is empty or None\"\n\n    # Basic validations: if positions returned, check structure for each\n    if isinstance(positions_data, list):\n        for pos in positions_data:\n            assert \"accountId\" in pos or \"account_id\" in pos or \"accountId\" in pos, \"Position missing account ID\"\n            assert \"quantity\" in pos or \"qty\" in pos or \"size\" in pos, \"Position missing quantity/size\"\n    elif isinstance(positions_data, dict):\n        # Sometimes positions might be wrapped in a dict with keys like 'positions' or similar\n        if \"positions\" in positions_data:\n            assert isinstance(positions_data[\"positions\"], list), \"'positions' key is not a list\"\n        else:\n            # just assert keys presence that can represent position info\n            keys = positions_data.keys()\n            assert any(k.lower().find(\"account\") >= 0 for k in keys), \"No account related field in positions response\"\n    else:\n        assert False, f\"Unexpected data type for positions response: {type(positions_data)}\"\n\n    # Latency check: ensure response time is minimal (e.g. below 1 second)\n    # Note: This is an indicative check; adjust threshold if environment differs\n    response_time = positions_resp.elapsed.total_seconds()\n    assert response_time < 1.0, f\"Positions API response latency too high: {response_time:.3f} seconds\"\n\ntest_validate_positions_api_minimal_latency_response()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 62, in test_validate_positions_api_minimal_latency_response\nAssertionError: Positions API response latency too high: 1.335 seconds\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-25T21:03:23.696Z",
    "modified": "2025-10-25T21:03:55.296Z"
  },
  {
    "projectId": "438a93da-61b6-417f-96df-03acf219046d",
    "testId": "47aeb3c9-37dd-4cf9-9040-7e35db1038a4",
    "userId": "3408e4a8-2001-7012-102b-59e7bbe0cb20",
    "title": "TC007-validate_pending_orders_api_response",
    "description": "Test the /api/v1/trading/orders/pending GET endpoint to verify it returns the list of pending orders with high-frequency trading optimized caching.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000/api/v1/trading/orders/pending\"\nTIMEOUT = 30\n\n\ndef test_validate_pending_orders_api_response():\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(BASE_URL, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to pending orders endpoint failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected HTTP 200 OK but got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # The response should be a list or dict containing orders; adapt below as per expected format\n    # Since no explicit schema is provided for the response, we check basic assumptions\n    assert isinstance(data, (list, dict)), \"Response JSON should be a list or dict\"\n\n    # If response is dict and contains list of orders, verify that field exists and is a list\n    # Here, we try to check if typical expected structure applies (e.g. 'orders' key)\n    if isinstance(data, dict):\n        # Accept either direct list or dictionary contains orders list or keys\n        # If keys exist check for presence of pending orders\n        # This is a generic check due to lack of exact schema\n        # Check some keys typical for orders list response\n        if \"orders\" in data:\n            orders = data[\"orders\"]\n            assert isinstance(orders, list), \"'orders' field should be a list\"\n            # Optionally check structure of one order if present\n            if orders:\n                order = orders[0]\n                assert isinstance(order, dict), \"Each order should be a dict\"\n                # Check essential fields in order if any known, minimal check:\n                expected_keys = [\"order_id\", \"account_id\", \"status\"]\n                for key in expected_keys:\n                    assert key in order, f\"Order should contain '{key}' field\"\n        else:\n            # If no 'orders' key, just verify keys and types in dict to cover coverage\n            # Should contain keys expected by the Orders API, minimally check keys\n            # or assume response directly a dict of orders or metadata\n            assert len(data) > 0, \"Response dict should not be empty\"\n    else:\n        # If response is a list of orders directly\n        if data:\n            order = data[0]\n            assert isinstance(order, dict), \"Each order should be a dict\"\n            expected_keys = [\"order_id\", \"account_id\", \"status\"]\n            for key in expected_keys:\n                assert key in order, f\"Order should contain '{key}' field\"\n\n\ntest_validate_pending_orders_api_response()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-25T21:03:23.701Z",
    "modified": "2025-10-25T21:03:51.068Z"
  },
  {
    "projectId": "438a93da-61b6-417f-96df-03acf219046d",
    "testId": "ad99d9ac-65f3-4d1c-94bd-b2762784e837",
    "userId": "3408e4a8-2001-7012-102b-59e7bbe0cb20",
    "title": "TC008-validate_account_balances_api_response",
    "description": "Test the /api/v1/trading/balances GET endpoint to ensure it returns accurate account balances including aggregated totals.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000/api/v1/trading/balances\"\nTIMEOUT = 30\n\ndef test_validate_account_balances_api_response():\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(BASE_URL, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {BASE_URL} failed: {e}\"\n\n    # Validate response is JSON and structure expected\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # The response should contain account balances and aggregated totals\n    # Since the schema is not detailed in PRD, we check presence of typical fields or list and totals\n    # Commonly balances API might return a list named 'balances' or 'accounts' and some summary fields\n    # We assert data should be a dict\n    assert isinstance(data, dict), \"Response JSON should be an object\"\n\n    # Check that keys related to balances exist\n    # We expect at minimum a list or dict of balances. Common might be 'balances' or 'accounts'\n    possible_balance_keys = ['balances', 'accounts', 'total_balance', 'aggregated_totals']\n    keys_found = set(data.keys())\n    assert any(k in keys_found for k in possible_balance_keys), f\"Response JSON keys missing expected balance-related keys: {possible_balance_keys}\"\n\n    # If balances or accounts present, check it is a list and contains expected fields\n    balance_list_key = None\n    for key in ['balances', 'accounts']:\n        if key in data:\n            balance_list_key = key\n            break\n\n    if balance_list_key:\n        balances = data[balance_list_key]\n        assert isinstance(balances, list), f\"{balance_list_key} should be a list\"\n        if len(balances) > 0:\n            # Check that each balance item includes at least an account identifier and balance amount fields (typical names: 'account_id', 'balance', 'currency')\n            first_item = balances[0]\n            assert isinstance(first_item, dict), f\"Items in {balance_list_key} should be objects\"\n            # Check for keys that usually represent account and balance\n            has_account_id = any(k.lower() in first_item for k in ['account_id', 'id', 'account'])\n            has_balance_amount = any(k.lower() in first_item for k in ['balance', 'amount', 'total'])\n            assert has_account_id, f\"Balance items should contain an account identifier field\"\n            assert has_balance_amount, f\"Balance items should contain a balance amount field\"\n\n    # Check aggregated totals if present - could be numeric fields in the root dict\n    numeric_aggregated_keys = ['total_balance', 'aggregated_totals', 'total', 'sum']\n    numeric_keys_found = [k for k in numeric_aggregated_keys if k in data]\n    for key in numeric_keys_found:\n        assert isinstance(data[key], (int, float)), f\"Aggregated total field '{key}' should be numeric\"\n\ntest_validate_account_balances_api_response()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-25T21:03:23.705Z",
    "modified": "2025-10-25T21:03:52.796Z"
  },
  {
    "projectId": "438a93da-61b6-417f-96df-03acf219046d",
    "testId": "6bb851b6-8f59-452f-9cc5-c232b82798ea",
    "userId": "3408e4a8-2001-7012-102b-59e7bbe0cb20",
    "title": "TC009-validate_health_check_api_response",
    "description": "Test the /api/v1/trading/health GET endpoint to verify it returns the system health status successfully without failure.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000/api/v1/trading\"\nTIMEOUT = 30\nHEADERS = {\n    \"Accept\": \"application/json\"\n}\n\ndef validate_health_check_api_response():\n    url = f\"{BASE_URL}/health\"\n    try:\n        response = requests.get(url, headers=HEADERS, timeout=TIMEOUT)\n        response.raise_for_status()\n        data = response.json()\n        assert isinstance(data, dict), \"Response is not a JSON object\"\n        # Assuming health response includes keys indicating health status\n        # We check for common keys like 'status' or 'health', or at least not empty\n        assert data, \"Health check response is empty\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"HTTP request failed: {e}\"\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\nvalidate_health_check_api_response()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-25T21:03:23.710Z",
    "modified": "2025-10-25T21:03:53.629Z"
  }
]
